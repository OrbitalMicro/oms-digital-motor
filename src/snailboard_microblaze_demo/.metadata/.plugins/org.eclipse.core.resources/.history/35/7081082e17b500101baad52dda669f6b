/******************************************************************************
*
* Copyright (C) 2009 - 2014 Xilinx, Inc.  All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* Use of the Software is limited solely to applications:
* (a) running on a Xilinx device, or
* (b) that interact with a Xilinx device through a bus or interconnect.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
* XILINX  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
* OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*
* Except as contained in this notice, the name of the Xilinx shall not be used
* in advertising or otherwise to promote the sale, use or other dealings in
* this Software without prior written authorization from Xilinx.
*
******************************************************************************/

/* AUTOGENERATED COMMENTS
 *
 *
 * This application configures UART 16550 to baud rate 9600.
 * PS7 UART (Zynq) is not initialized by this application, since
 * bootrom/bsp configures it to baud rate 115200
 *
 * ------------------------------------------------
 * | UART TYPE   BAUD RATE                        |
 * ------------------------------------------------
 *   uartns550   9600
 *   uartlite    Configurable only in HW design
 *   ps7_uart    115200 (configured by bootrom/bsp)
 */



/*** Libraries ***/
#include "xparameters.h"	// System related parameters (produced by Vitis based on the provided XSA or HDF)
#include "sleep.h"			// Time based functions
#include "xil_printf.h"
#include <stdio.h>
#include <math.h>
#include <xil_exception.h>
#include "xintc.h"


#define AXI_IP_TEST_BUILD_DATE (XPAR_TEST_IP_0_BASEADDR + 8)
#define AXI_IP_TEST_LATENCY_MEASURE (XPAR_TEST_IP_0_BASEADDR + 0x118)
//#define AXI_IP_TEST_IRQ (0x40010000)
#define ENABLE_PRINT 1


// --- Define Motor IP Addresses
#define MOTOR_3PHASE_ENCODER_CTRL_REG                 (XPAR_AXI_MOTOR_SPI_3PHASE_1_BASEADDR )
#define MOTOR_3PHASE_PWM_CTRL_REG                     (XPAR_AXI_MOTOR_SPI_3PHASE_1_BASEADDR + 0x4)
#define MOTOR_3PHASE_ENCODER_DECODER_LUT_ADDR_REG     (XPAR_AXI_MOTOR_SPI_3PHASE_1_BASEADDR + 0x8)
#define MOTOR_3PHASE_ENCODER_DECODER_DATA_STATUS_REG  (XPAR_AXI_MOTOR_SPI_3PHASE_1_BASEADDR + 0xC)
#define MOTOR_3PHASE_AMPLITUDE_CTRL_REG               (XPAR_AXI_MOTOR_SPI_3PHASE_1_BASEADDR + 0x10)
#define MOTOR_3PHASE_ENCODER_STATUS_REG               (XPAR_AXI_MOTOR_SPI_3PHASE_1_BASEADDR + 0x14)
#define MOTOR_3PHASE_PWM_STATUS_REG_1                 (XPAR_AXI_MOTOR_SPI_3PHASE_1_BASEADDR + 0x18)
#define MOTOR_3PHASE_PWM_STATUS_REG_2                 (XPAR_AXI_MOTOR_SPI_3PHASE_1_BASEADDR + 0x1C)
#define MOTOR_3PHASE_PACKET_24_BITS                   (XPAR_AXI_MOTOR_SPI_3PHASE_1_BASEADDR + 0x20)


#define AMPLITUDE_MIN -45000
#define AMPLITUDE_MAX 45000
#define AMPLITUDE_INCR 5000
#define IRQ_AMPLITUDE_COUNT 30


/*
(0x00) Reg 0 - Encoder Control Register (R/W)
    bit 0       - Encoder sampling enabled (R/W)
    bits 15:8   - Encoder sample clock divider (R/W)
    bits 31:16  - Encoder sample trigger delay (R/W)
(0x04) Reg 1 - PWM Control Register (R/W)
    bit 0       - PWM interface enabled (R/W)
    bit 1       - Sinusoid lookup source (0: Use encoder, 1: User input) (R/W)
    bit 11:8    - PWM period width (PWM period is 2**(n+1)) (R/W)
    bits 31:16  - Sinusiod lookup user input (R/W)
*/


uint32_t* bramPtr_countIdx = (uint32_t*)(XPAR_MBLAZE_MEMORY_CTRL_S_AXI_BASEADDR + 12); // 4 byte offset

uint32_t* LatencyControl = (uint32_t*)(AXI_IP_TEST_LATENCY_MEASURE);

int32_t* amplitudeCtrl = (int32_t*)(MOTOR_3PHASE_AMPLITUDE_CTRL_REG); // This is an sfix17 bit number so it can range from +2^16 to -2^16

uint32_t* encoderRegRead = (uint32_t*)(MOTOR_3PHASE_ENCODER_STATUS_REG);

uint32_t* encoderPacket24bit = (uint32_t*)(MOTOR_3PHASE_PACKET_24_BITS);



float globalValue; // for testing..

// Function to return the sign of an integer
int get_sign_int(int num) {
    if (num > 0) {
        return 1;
    } else if (num < 0) {
        return -1;
    } else {
        return 0;
    }
}


void updateCountReg(uint32_t value)
{
	//*bramPtr_countIdx = value; // update count register
	if (ENABLE_PRINT)
	{
		printf("Divide example (%d / PI) = %f  \n", value, (float)(value/M_PI));
	}

}

void MyIsr_0(void *CallbackRef) {


	*((uint32_t *)AXI_IP_TEST_LATENCY_MEASURE) = 1;
    *((uint32_t *)AXI_IP_TEST_LATENCY_MEASURE) = 0;

    if (ENABLE_PRINT)
	{
    		printf("ISR0: Got interrupt! \n");
	}
}


uint32_t encoderIncrement;
int8_t flipSpeed = 1;
#define MAX_SPEED_ARRAY 18
int arrAmpSpeeds[MAX_SPEED_ARRAY] = {-60000,-55000,-50000,-45000, -40000,-35000, -30000,-25000,
									-20000, 20000, 25000, 30000, 35000, 40000,
									45000, 50000, 55000, 60000};
uint8_t arrayIdx;
void MyIsr_1(void *CallbackRef) {
	// Add your specific interrupt handling logic here
   //xil_printf("ISR1: Interrupt occurred! \n");
	int nextSpeed;
	int currentSpeed;
	globalValue += *bramPtr_countIdx  / M_PI;

	if (encoderIncrement < IRQ_AMPLITUDE_COUNT){
		encoderIncrement += 1; // increment this every time encoder changes
	}
	else{
		encoderIncrement = 0;

		if (flipSpeed == 1)
		{
			arrayIdx = arrayIdx + 1;
		}
		else{
			arrayIdx = arrayIdx - 1;
		}

		if (arrayIdx >= MAX_SPEED_ARRAY-1 || arrayIdx <= 0) {
			flipSpeed *= -1;

			//fflush(stdout);
		}

 		nextSpeed = arrAmpSpeeds[arrayIdx];

 		currentSpeed = *amplitudeCtrl;

		if (get_sign_int(currentSpeed) != get_sign_int(nextSpeed))
		{
			printf("[WARNING: printf will cause IRQ misses!] Changing motor direction. IRQ Count = %d [%d %d] \n",*bramPtr_countIdx,currentSpeed,nextSpeed);
		}

 		//*amplitudeCtrl = nextSpeed; // assign new amplitude speed
	}

	*bramPtr_countIdx = *bramPtr_countIdx + 1; // update SW IRQ counter value in shared memory

}

unsigned int extract_bottom_11_bits(uint32_t word) {
    return word & 0x7FF;  // Mask for the lowest 11 bits (binary: 0000 0111 1111 1111)
}

unsigned int extract_top_encoder_bits(uint32_t word) {
    return word >> 11;  // Mask for the lowest 11 bits (binary: 0000 0111 1111 1111)
}


void initMotor() {
	/*
	Enable encoder
		mwr 0x43c00000 0xFFFF0201
    Clear SW Count
		mwr 0x4200000C 0
	Disable motor PWM
	 	mwr 0x43c00004 0x00000F00
 	Set IRQ threshold here
		mwr 0x43c00024 5
	Give a non-zero value to the amplitude
		mwr 0x43c00010 0xFFFF
	Re-enable PWM - motor will start to spin..
		mwr 0x43c00004 0x00000F01
	*/

	*((int *)(MOTOR_3PHASE_ENCODER_CTRL_REG)) = 0xFFFF0201; // enable encoder
	*((int *)(MOTOR_3PHASE_ENCODER_DECODER_DATA_STATUS_REG)) = 0; // clear counter
	*((int *)(MOTOR_3PHASE_PWM_CTRL_REG)) = 0x00000F00; // disable motor PWM
	*((int *)(0x43c00024)) = 5; // set IRQ threshold
	*((int *)(MOTOR_3PHASE_AMPLITUDE_CTRL_REG)) = 0;
	*((int *)(MOTOR_3PHASE_PWM_CTRL_REG)) = 0x00000F01; // enable motor PWM

	printf("===== Finished setting up motor registers =====\n");


}

XIntc InterruptController; // Instance of the Interrupt Controller




int main()
{

	printf(" ================================================ \n");
    init_platform(); // unsure if this is needed unless we are cacheing???

    /* motor initialization all here */
   // initMotor();

    // set initial speed here
    //*amplitudeCtrl = arrAmpSpeeds[0];



	int Status;

	    // Initialize the AXI Interrupt Controller
	    Status = XIntc_Initialize(&InterruptController, XPAR_AXI_INTC_0_DEVICE_ID);
	    if (Status != XST_SUCCESS) {
	        xil_printf("AXI Interrupt Controller initialization failed!\\n\\r");
	        return XST_FAILURE;
	    }

	    // Connect the ISR to the AXI Interrupt Controller - callback
	   Status = XIntc_Connect(&InterruptController, XPAR_AXI_INTC_0_TEST_IP_0_ISR_TRIGGER_0_INTR,
							  (XInterruptHandler)MyIsr_0, (void *)0);
	   if (Status != XST_SUCCESS) {
		   xil_printf("ISR0: Connecting ISR to Interrupt Controller failed!\\n\\r");
		   return XST_FAILURE;
	   }

//	   Status = XIntc_Connect(&InterruptController, XPAR_AXI_INTC_0_TEST_IP_0_ISR_TRIGGER_1_INTR,
	   Status = XIntc_Connect(&InterruptController, XPAR_AXI_INTC_0_AXI_MOTOR_SPI_3PHASE_1_ENCODER_IRQ_O_INTR,
							  (XInterruptHandler)MyIsr_1, (void *)0);
	   if (Status != XST_SUCCESS) {
		   xil_printf("ISR1: Connecting ISR to Interrupt Controller failed!\\n\\r");
		   return XST_FAILURE;
	   }

	   // Start the AXI Interrupt Controller
	   Status = XIntc_Start(&InterruptController, XIN_REAL_MODE);
	   if (Status != XST_SUCCESS) {
		   xil_printf("Starting Interrupt Controller failed!\\n\\r");
		   return XST_FAILURE;
	   }

	   // Enable all interrupts
	   XIntc_Enable(&InterruptController,
			   XPAR_AXI_INTC_0_TEST_IP_0_ISR_TRIGGER_0_INTR);

	   XIntc_Enable(&InterruptController,
			   XPAR_AXI_INTC_0_AXI_MOTOR_SPI_3PHASE_1_ENCODER_IRQ_O_INTR);

	   // Initialize and enable MicroBlaze exceptions
	   Xil_ExceptionInit();
	   Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
									(Xil_ExceptionHandler)XIntc_InterruptHandler,
									&InterruptController);
	   Xil_ExceptionEnable(); // this will enable interrupts underneath

	   // Enable interrupts in your peripheral (e.g., XGpio_InterruptEnable(&Gpio, GPIO_CHANNEL);)

	   xil_printf("Done setting up interrupts...\n");




	printf(" ================================================ \n");

	// Current switch value will be stored here
	uint8_t* bramPtr_idx0 = (uint8_t*)XPAR_MBLAZE_MEMORY_CTRL_S_AXI_BASEADDR; // one byte access
	uint32_t* bramPtr_idx1 = (uint32_t*)(XPAR_MBLAZE_MEMORY_CTRL_S_AXI_BASEADDR + 4); // 4 byte offset
	uint32_t* bramPtr_idx2 = (uint32_t*)(XPAR_MBLAZE_MEMORY_CTRL_S_AXI_BASEADDR + 8); // 4 byte offset


	uint8_t tmpVal0 = 0;
    uint32_t tmpVal1 = 0;
    uint32_t tmpVal2 = 0; // 4 byte addressing

    uint32_t writeCount = 0; // 4 byte addressing


    *bramPtr_countIdx = 0; // reset count everytime application starts up

    /** Application Loop **/
	*bramPtr_idx0 = 12; // write some constant value in BRAM
	//*amplitudeCtrl = 0X00; // write to register

	printf(" ================================================ \n");
	printf(" ================================================ \n");
	printf(" =================WEATHER STREAM================= \n");
	printf(" =========== MICROBLAZE PROJECT START =========== \n");
	printf(" ================================================ \n");
	printf(" ================================================ \n");


	printf("AXI Test: HDL Coder IP Build Date = %u \n",*((uint32_t *)AXI_IP_TEST_BUILD_DATE));

	printf("Motor control register read [amplitude 0x%X = %u ] \n", amplitudeCtrl, *(uint16_t*)amplitudeCtrl);

	while(1)
	{

		/* Shared memory access:
		 * This will demonstrate shared memory access between Microblaze and ARM PS using a dual port block ram
		 * Everytime a memory value changes for 0x0, 0x4,0x8, report the value. Then update another register at 0xC
		 */

		if (tmpVal0 != *bramPtr_idx0)
		{
			tmpVal0 = *bramPtr_idx0; // update old value...
			writeCount += 1;
			updateCountReg(writeCount);
			printf("Value changed = %d \n", *bramPtr_idx0);
		}


		if (tmpVal1 != *bramPtr_idx1)
		{
			tmpVal1 = *bramPtr_idx1;
			writeCount += 1;
			updateCountReg(writeCount);
			printf("Value changed = %d \n", *bramPtr_idx1);
		}

		if (tmpVal2 != *bramPtr_idx2)
		{
			tmpVal2 = *bramPtr_idx2;
			writeCount += 1;
			updateCountReg(writeCount);
			printf("Value changed = %d \n", *bramPtr_idx2);
		}


		// 1ms delay
		usleep(100000);
	}

	cleanup_platform();
}
